{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Plycutter - STL to finger-jointed DXF slicer Author: Tuomas Lukka, tuomas@hipcode.fi Official homepage Github repo Introductory blog post with lots of pictures Introduction Plycutter is a program that takes a 3D model in an .stl file and generates 2D .dxf files suitable for laser cutting, with generated finger joints between material sheets where appropriate. The 3D needs to be designed in a way where the sheets are clearly visible (e.g., using the CAD program's 'shell' command). Example (images on the right): pen holder consisting of two stacked octahedra (scale model from 3mm plywood). Top: CAD model. The CAD model was designed as two octahedra on top of each other and the 'shell' command in the CAD program (Fusion 360) was used to produce the shape consisting of sheets. A further cut on the top was made to create the curved edges. This model was then exported as a .stl Middle: Result of running plycutter on the .stl file to produce .dxf file for laser cutter. Bottom: the laser-cut plywood parts assembled. In cases where the vertical cuts from the laser cutter cannod exactly follow the model (such as the tips of the top triangle or the non-90-degree joints), plycutter tries to retain as much material as possible so that a quick sanding or filing operation will get the desired shape. For non-90-degree joints, some gaps are unavoidable but a multitools and wood filler make quick work of those. For more showcase images, see Plycutter summary PDF Note Plycutter is alpha-stage software and probably contains many bugs. Please report any bugs as issues in the github project, preferably with a pull request with a failing test, or at least a minimal .stl file and command line for reproducing the problem. Purpose / use cases Plycutter is at its best for making one-off prototypes or small production runs, or for generative objects where each object is custom-generated from user input. Unlike with 3D printers, the workspace is much larger (depending on the laser cutter used; with a little planning, it is also possible to make much larger objects than your laser cutter - only each sheet must fit). The author has personally used it to iterate on some household object concepts, where it provides a fast and robust way (compared to 3D printing, for example) of iterating large objects. Currently, the program generates the fingers somewhat randomly which makes it next to impossible to assemble the objects wrong and also makes them into interesting puzzles. Installing plycutter Installing dependencies On a recent ubuntu, you can do the following. sudo apt-get install libgeos-c1v5 libmpc-dev libspatialindex-dev python -m pip install --upgrade pip python -m pip install flake8 pytest if [ -f requirements.txt ]; then pip install -r requirements.txt; fi This is copied from the github test action so it should work ok. On MacOS, the author uses conda to install the dependencies, see environment.yml . Installing plycutter itself Conventional method using setup.py To install plycutter into your current python environment, run the command python setup.py install After this, running plycutter as a shell command should work Using pipx It is also possible to install plycutter and its dependencies via pipx . pipx install git+https://github.com/tjltjl/plycutter.git See the pipx dodumentation for details Basic usage; Getting started Install plycutter. Run the tests (pytest) to ensure all dependencies work. Next, run the input file PlyTest0.1.stl which contains a very simple object consisting of two sheets that meet at a corner. We run plycutter from the command line using the following command: plycutter -o foo.dxf --thickness 6 ./tests/data/PlyTest0.1.stl which produces the output foo.dxf . You can open it in, e.g., Inkscape. The following image shows the contents of such a file; the lines on the left and on the bottom are Inkscape's paper edge. Now it is possible to run this file in a laser cutter to obtain two pieces of e.g. plywood or acrylic that fit each other perfectly. plycutter Command line options usage: plycutter [-h] [--thickness THICKNESS] [--min_finger_width MIN_FINGER_WIDTH] [--max_finger_width MAX_FINGER_WIDTH] [--support_radius SUPPORT_RADIUS] [--debug] [--final_dilation FINAL_DILATION] [--random_seed RANDOM_SEED] [--only_sheets ONLY_SHEETS] [-o OUTPUT_FILE] infile positional arguments: infile STL file to process optional arguments: -h, --help show this help message and exit --thickness THICKNESS Set the thickness of sheets to find. (default: 6) --min_finger_width MIN_FINGER_WIDTH Set minimum width for generated fingers. (default: 3) --max_finger_width MAX_FINGER_WIDTH Set maximum width for generated fingers. (default: 5) --support_radius SUPPORT_RADIUS Set maximum range for generating material on a sheet where neither surface is visible (default: 12) --debug Turn on debugging. (default: False) --final_dilation FINAL_DILATION Final dilation (laser cutter kerf compensation) (default: 1/20) --random_seed RANDOM_SEED Random seed for pseudo-random heuristics (default: 42) --only_sheets ONLY_SHEETS Not implemented yet (default: None) -o OUTPUT_FILE, --output_file OUTPUT_FILE File to write the DXF output in (default: None) The most relevant known limitations Plycutter is a hobby project, published in hope that it will be useful. Currently, the author (Tuomas Lukka) is in freelancer mode so feel free to contact the author to offer a consulting gig if there is a particular limitation you would like to see get worked on ASAP (or for other projects :) ). For large models and models with many curves, plycutter is currently relatively slow. Even for small models, getting some speedup would be very welcome. The slowness is due to the exact 2D library that was written as a quick replacement to a commonly used off-the-shelf Python 2D library when it turned out that rounding errors from floats made it impossible to use in this work (the joint fingers are generated along linees and getting rounding errors that flip vertices' area were causing assertion failures). There are several badly scaling algorithms in plycutter's own 2D geometry library and those algorithms need to be replaced with faster ones. The ideal solutioin would be to replace the 2D library wth an external one that can do exact, rational geometry fast, but so far, I have not had success with this. The Geom2D API has been kept simple for this reason. Shallow joints (between 135 and 180 degrees) are currently handled badly, with finger lengths becoming extreme. The system should understand when it does not make sense to make the fingers longer. Long joints where more than 2 sheets meet are handled very rudimentarily and can produce unexpected results. Writing an algorithm that does better is fairly straightforward but hasn't been done yet. The function that makes the simplistic decisions is heuristic_multi_inter_single_decisions in plycutter/heuristics.py . For two sheets that cross each other in an \"X\" shape, plycutter will currently produce output that would only be assemblable in 4D. I.e. it will produce holes on both sheets that would fit together if it were possible to assemble the sheets. The real solution here is to allow plycutter to cut one of the sheets into parts but doing that correctly requires... ...buildability analysis. It is possible to make 2D patterns that cannot be assembled. For example, the two interlocking cubes example could have produced such a pattern but luckily did not. Curved sheets are not yet supported (curved sheet edges work fine; of course they get subdivided into lines in the STL export). The architecture is should be fairly easy to extend in that direction: the Sheet , Inter and InterSide objects are designed in a way that may make this easy. Representing the InterSide as a subdivided polygonal curve is probably the easiest approach to integrate with the current Geom2D code. Naturally, the curved sheets should only be developable surfaces(Wikipedia) Currently, plycutter is not able to make use of the capabilities of 5-axis laser or water cutters or mills, mostly because the author has no access to such machines. If you are able to arrange such access, please get in touch. The biggest plus of 5 axes is that in non-90-degree joints, there will be no gaps or protruding parts. However, it gets better: 5 axes will enable a wide variety of joint shapes. Milling or water cutting may require dog bone corners which are also not implemented for the above reason. The joint pieces that belong together are not marked in any way currently. Adding a laser-carved number would be a great way to help the assembly process when there are many parts (for example, the dollhouse stairs were quite an interesting task to assemble...)","title":"Plycutter - STL to finger-jointed DXF slicer"},{"location":"#plycutter-stl-to-finger-jointed-dxf-slicer","text":"Author: Tuomas Lukka, tuomas@hipcode.fi Official homepage Github repo Introductory blog post with lots of pictures","title":"Plycutter - STL to finger-jointed DXF slicer"},{"location":"#introduction","text":"Plycutter is a program that takes a 3D model in an .stl file and generates 2D .dxf files suitable for laser cutting, with generated finger joints between material sheets where appropriate. The 3D needs to be designed in a way where the sheets are clearly visible (e.g., using the CAD program's 'shell' command). Example (images on the right): pen holder consisting of two stacked octahedra (scale model from 3mm plywood). Top: CAD model. The CAD model was designed as two octahedra on top of each other and the 'shell' command in the CAD program (Fusion 360) was used to produce the shape consisting of sheets. A further cut on the top was made to create the curved edges. This model was then exported as a .stl Middle: Result of running plycutter on the .stl file to produce .dxf file for laser cutter. Bottom: the laser-cut plywood parts assembled. In cases where the vertical cuts from the laser cutter cannod exactly follow the model (such as the tips of the top triangle or the non-90-degree joints), plycutter tries to retain as much material as possible so that a quick sanding or filing operation will get the desired shape. For non-90-degree joints, some gaps are unavoidable but a multitools and wood filler make quick work of those. For more showcase images, see Plycutter summary PDF Note Plycutter is alpha-stage software and probably contains many bugs. Please report any bugs as issues in the github project, preferably with a pull request with a failing test, or at least a minimal .stl file and command line for reproducing the problem.","title":"Introduction"},{"location":"#purpose-use-cases","text":"Plycutter is at its best for making one-off prototypes or small production runs, or for generative objects where each object is custom-generated from user input. Unlike with 3D printers, the workspace is much larger (depending on the laser cutter used; with a little planning, it is also possible to make much larger objects than your laser cutter - only each sheet must fit). The author has personally used it to iterate on some household object concepts, where it provides a fast and robust way (compared to 3D printing, for example) of iterating large objects. Currently, the program generates the fingers somewhat randomly which makes it next to impossible to assemble the objects wrong and also makes them into interesting puzzles.","title":"Purpose / use cases"},{"location":"#installing-plycutter","text":"","title":"Installing plycutter"},{"location":"#installing-dependencies","text":"On a recent ubuntu, you can do the following. sudo apt-get install libgeos-c1v5 libmpc-dev libspatialindex-dev python -m pip install --upgrade pip python -m pip install flake8 pytest if [ -f requirements.txt ]; then pip install -r requirements.txt; fi This is copied from the github test action so it should work ok. On MacOS, the author uses conda to install the dependencies, see environment.yml .","title":"Installing dependencies"},{"location":"#installing-plycutter-itself","text":"","title":"Installing plycutter itself"},{"location":"#conventional-method-using-setuppy","text":"To install plycutter into your current python environment, run the command python setup.py install After this, running plycutter as a shell command should work","title":"Conventional method using setup.py"},{"location":"#using-pipx","text":"It is also possible to install plycutter and its dependencies via pipx . pipx install git+https://github.com/tjltjl/plycutter.git See the pipx dodumentation for details","title":"Using pipx"},{"location":"#basic-usage-getting-started","text":"Install plycutter. Run the tests (pytest) to ensure all dependencies work. Next, run the input file PlyTest0.1.stl which contains a very simple object consisting of two sheets that meet at a corner. We run plycutter from the command line using the following command: plycutter -o foo.dxf --thickness 6 ./tests/data/PlyTest0.1.stl which produces the output foo.dxf . You can open it in, e.g., Inkscape. The following image shows the contents of such a file; the lines on the left and on the bottom are Inkscape's paper edge. Now it is possible to run this file in a laser cutter to obtain two pieces of e.g. plywood or acrylic that fit each other perfectly.","title":"Basic usage; Getting started"},{"location":"#plycutter-command-line-options","text":"usage: plycutter [-h] [--thickness THICKNESS] [--min_finger_width MIN_FINGER_WIDTH] [--max_finger_width MAX_FINGER_WIDTH] [--support_radius SUPPORT_RADIUS] [--debug] [--final_dilation FINAL_DILATION] [--random_seed RANDOM_SEED] [--only_sheets ONLY_SHEETS] [-o OUTPUT_FILE] infile positional arguments: infile STL file to process optional arguments: -h, --help show this help message and exit --thickness THICKNESS Set the thickness of sheets to find. (default: 6) --min_finger_width MIN_FINGER_WIDTH Set minimum width for generated fingers. (default: 3) --max_finger_width MAX_FINGER_WIDTH Set maximum width for generated fingers. (default: 5) --support_radius SUPPORT_RADIUS Set maximum range for generating material on a sheet where neither surface is visible (default: 12) --debug Turn on debugging. (default: False) --final_dilation FINAL_DILATION Final dilation (laser cutter kerf compensation) (default: 1/20) --random_seed RANDOM_SEED Random seed for pseudo-random heuristics (default: 42) --only_sheets ONLY_SHEETS Not implemented yet (default: None) -o OUTPUT_FILE, --output_file OUTPUT_FILE File to write the DXF output in (default: None)","title":"plycutter Command line options"},{"location":"#the-most-relevant-known-limitations","text":"Plycutter is a hobby project, published in hope that it will be useful. Currently, the author (Tuomas Lukka) is in freelancer mode so feel free to contact the author to offer a consulting gig if there is a particular limitation you would like to see get worked on ASAP (or for other projects :) ). For large models and models with many curves, plycutter is currently relatively slow. Even for small models, getting some speedup would be very welcome. The slowness is due to the exact 2D library that was written as a quick replacement to a commonly used off-the-shelf Python 2D library when it turned out that rounding errors from floats made it impossible to use in this work (the joint fingers are generated along linees and getting rounding errors that flip vertices' area were causing assertion failures). There are several badly scaling algorithms in plycutter's own 2D geometry library and those algorithms need to be replaced with faster ones. The ideal solutioin would be to replace the 2D library wth an external one that can do exact, rational geometry fast, but so far, I have not had success with this. The Geom2D API has been kept simple for this reason. Shallow joints (between 135 and 180 degrees) are currently handled badly, with finger lengths becoming extreme. The system should understand when it does not make sense to make the fingers longer. Long joints where more than 2 sheets meet are handled very rudimentarily and can produce unexpected results. Writing an algorithm that does better is fairly straightforward but hasn't been done yet. The function that makes the simplistic decisions is heuristic_multi_inter_single_decisions in plycutter/heuristics.py . For two sheets that cross each other in an \"X\" shape, plycutter will currently produce output that would only be assemblable in 4D. I.e. it will produce holes on both sheets that would fit together if it were possible to assemble the sheets. The real solution here is to allow plycutter to cut one of the sheets into parts but doing that correctly requires... ...buildability analysis. It is possible to make 2D patterns that cannot be assembled. For example, the two interlocking cubes example could have produced such a pattern but luckily did not. Curved sheets are not yet supported (curved sheet edges work fine; of course they get subdivided into lines in the STL export). The architecture is should be fairly easy to extend in that direction: the Sheet , Inter and InterSide objects are designed in a way that may make this easy. Representing the InterSide as a subdivided polygonal curve is probably the easiest approach to integrate with the current Geom2D code. Naturally, the curved sheets should only be developable surfaces(Wikipedia) Currently, plycutter is not able to make use of the capabilities of 5-axis laser or water cutters or mills, mostly because the author has no access to such machines. If you are able to arrange such access, please get in touch. The biggest plus of 5 axes is that in non-90-degree joints, there will be no gaps or protruding parts. However, it gets better: 5 axes will enable a wide variety of joint shapes. Milling or water cutting may require dog bone corners which are also not implemented for the above reason. The joint pieces that belong together are not marked in any way currently. Adding a laser-carved number would be a great way to help the assembly process when there are many parts (for example, the dollhouse stairs were quite an interesting task to assemble...)","title":"The most relevant known limitations"},{"location":"acknowledgments/","text":"Thanks to Timo Jokitalo for pre-release feedback and suggesting the blog post. Thanks to Antti H\u00e4m\u00e4l\u00e4inen for the courage to test plycutter with a large acrylic project. Thanks to Janne Kujala for discussions and the first test model not by the author. Thanks to my (tjltjl's) family for ideas, requirements and patience.","title":"Acknowledgments"},{"location":"dev/","text":"Internals for developers Coding standard PEP8 (autopep8). flake8 must pass with no warnings. Prefer immutable objects wherever appropriate. Use exact rational numbers wherever appropriate. Do approximate operations only at points where it does not hurt the exactness of the results. The reason for this is that using exact 2D geometry gets rid of a lot of possible problem cases due to e.g. triangle flipping due to rounding errors. Plycutter process There are three different stages to plycutter: Reading the .STL file into a SheetPlex . Creating a \"free\" SheetBuild object and incrementally making heuristic choices within it. Post-processing and writing out the .dxf files. SheetPlex A SheetPlex is a mostly policy-free representation of the input model, after finding where the possible sheets in the input model are. It contains slices through the input model to provide information for the heuristics as well as the relationships between the sheets. Intersections between sheets are represented, as well as the projection of the intersection to either of the sheets involved (this is important for the heuristics) SheetBuild A SheetBuild is the \"blackboard\" object used by the heuristic routines. It starts life as a very open description of the situation (\"there could be material here on this sheet and here\") and as the heuristics progress, they make decisions and convert some possible points to certainty and some to impossibility, thereby creating the joint between two sheets. A SheetBuild is a persistent map implemented using pyrsistent . This way, none of the functions modify anything but only return a new version. This makes debugging the heuristics a lot easier since it is easy to save the state at each point in the heuristics chain and rerun a particular step with changed code, with confidence that things are as they should be. Heuristics The heuristics start by looking at the proposed joints to see which parts are clearly not meant to be implemented by a particular sheet (just slicing the 3D model produces surprising things here that the heuristics mostly remove). After this, the heuristics look at multi-intersections, i.e., the intersections of more than two sheets since those regions require special care. Currently, one sheet is chosen for all of such an area (this is a feature where improvements are still needed). After this, the heuristics look at the two-sheet intersections and generate fingers there. The heuristics are in the package plycutter.heuristics and their driver is in plycutter.canned . Writeout Currently, the only postprocessing is the kerf compensation by a fixed amount. More could be added here, such as dog-bone compensation (though that might also belong in an earlier stage, this needs to be figured out when adding it) Libraries Plycutter includes some libraries to provide a good API for implementing the heuristics. Geometry The main library components are the Geom1D and Geom2D classes. They implement exact polygonal sets in 1D and 2D space, in a way that disallows zero-measure object droppings or cavities. This is the same as 'regularized boolean set-operations' in CGAL. Geom1D Geom2D The implementation of Geom2D is the largest part of plycutter currently; replacing this with a better, external implementation would be wonderful.","title":"Internals for developers"},{"location":"dev/#internals-for-developers","text":"","title":"Internals for developers"},{"location":"dev/#coding-standard","text":"PEP8 (autopep8). flake8 must pass with no warnings. Prefer immutable objects wherever appropriate. Use exact rational numbers wherever appropriate. Do approximate operations only at points where it does not hurt the exactness of the results. The reason for this is that using exact 2D geometry gets rid of a lot of possible problem cases due to e.g. triangle flipping due to rounding errors.","title":"Coding standard"},{"location":"dev/#plycutter-process","text":"There are three different stages to plycutter: Reading the .STL file into a SheetPlex . Creating a \"free\" SheetBuild object and incrementally making heuristic choices within it. Post-processing and writing out the .dxf files.","title":"Plycutter process"},{"location":"dev/#sheetplex","text":"A SheetPlex is a mostly policy-free representation of the input model, after finding where the possible sheets in the input model are. It contains slices through the input model to provide information for the heuristics as well as the relationships between the sheets. Intersections between sheets are represented, as well as the projection of the intersection to either of the sheets involved (this is important for the heuristics)","title":"SheetPlex"},{"location":"dev/#sheetbuild","text":"A SheetBuild is the \"blackboard\" object used by the heuristic routines. It starts life as a very open description of the situation (\"there could be material here on this sheet and here\") and as the heuristics progress, they make decisions and convert some possible points to certainty and some to impossibility, thereby creating the joint between two sheets. A SheetBuild is a persistent map implemented using pyrsistent . This way, none of the functions modify anything but only return a new version. This makes debugging the heuristics a lot easier since it is easy to save the state at each point in the heuristics chain and rerun a particular step with changed code, with confidence that things are as they should be.","title":"SheetBuild"},{"location":"dev/#heuristics","text":"The heuristics start by looking at the proposed joints to see which parts are clearly not meant to be implemented by a particular sheet (just slicing the 3D model produces surprising things here that the heuristics mostly remove). After this, the heuristics look at multi-intersections, i.e., the intersections of more than two sheets since those regions require special care. Currently, one sheet is chosen for all of such an area (this is a feature where improvements are still needed). After this, the heuristics look at the two-sheet intersections and generate fingers there. The heuristics are in the package plycutter.heuristics and their driver is in plycutter.canned .","title":"Heuristics"},{"location":"dev/#writeout","text":"Currently, the only postprocessing is the kerf compensation by a fixed amount. More could be added here, such as dog-bone compensation (though that might also belong in an earlier stage, this needs to be figured out when adding it)","title":"Writeout"},{"location":"dev/#libraries","text":"Plycutter includes some libraries to provide a good API for implementing the heuristics.","title":"Libraries"},{"location":"dev/#geometry","text":"The main library components are the Geom1D and Geom2D classes. They implement exact polygonal sets in 1D and 2D space, in a way that disallows zero-measure object droppings or cavities. This is the same as 'regularized boolean set-operations' in CGAL.","title":"Geometry"},{"location":"dev/#geom1d","text":"","title":"Geom1D"},{"location":"dev/#geom2d","text":"The implementation of Geom2D is the largest part of plycutter currently; replacing this with a better, external implementation would be wonderful.","title":"Geom2D"},{"location":"installation/","text":"Installing plycutter Basic installation Linux On a recent ubuntu, you can do the following. sudo apt-get install libgeos-c1v5 libmpc-dev libspatialindex-dev python -m pip install --upgrade pip python -m pip install flake8 pytest if [ -f requirements.txt ]; then pip install -r requirements.txt; fi This is copied from the github test action so it should work ok. Conda On MacOS (and probably other OSes), you can use conda to install the dependencies using conda env update --file environment.yml in the main plycutter directory. If you like, you can create a new conda environment for plycutter before doing this. After installation You can run the tests using pytest .","title":"Installing plycutter"},{"location":"installation/#installing-plycutter","text":"","title":"Installing plycutter"},{"location":"installation/#basic-installation","text":"","title":"Basic installation"},{"location":"installation/#linux","text":"On a recent ubuntu, you can do the following. sudo apt-get install libgeos-c1v5 libmpc-dev libspatialindex-dev python -m pip install --upgrade pip python -m pip install flake8 pytest if [ -f requirements.txt ]; then pip install -r requirements.txt; fi This is copied from the github test action so it should work ok.","title":"Linux"},{"location":"installation/#conda","text":"On MacOS (and probably other OSes), you can use conda to install the dependencies using conda env update --file environment.yml in the main plycutter directory. If you like, you can create a new conda environment for plycutter before doing this.","title":"Conda"},{"location":"installation/#after-installation","text":"You can run the tests using pytest .","title":"After installation"},{"location":"api/plycutter/","text":"API documentation","title":"API documentation"},{"location":"api/plycutter/#api-documentation","text":"","title":"API documentation"},{"location":"api/plycutter/sheetbuild/","text":"plycutter.sheetbuild plycutter.sheetbuild.SheetBuild Data evolved by heuristics Semantics: chosen = set in stone ok = as far as we know, this could be chosen <= ok always. When chosen == ok, we are done Attributes sheet_chosen -- PMap(sheet_id, Geom2D). Sheet areas chosen to be included. sheet_ok -- PMap(sheet_id, Geom2D). Sheet areas that are not forbidden by e.g. other sheets or by not being included at all. interside_chosen -- PMap(sheet_id, Geom1D). For each interside, the regions where the interside's sheet has been chosen. interside_ok -- PMap(sheet_id, Geom1D). For each interside, the regions where it would still be ok to choose that side. There is a variety of sanity checks that can be made on a sheetbuild. The checks are relatively slow so by default they are made only infrequently (see sheetbuild.check_interval). Call sb.check(force=True) to force a check to happen. Methods check ( self , force = False ) Assert that various invariants are true. unchoose_interside ( self , interside_id , v ) State that the range v will never be chosen Create an as-free-as-possible SheetBuild for the given SheetPlex.","title":"plycutter.sheetbuild"},{"location":"api/plycutter/sheetbuild/#plycuttersheetbuild","text":"","title":"plycutter.sheetbuild"},{"location":"api/plycutter/sheetbuild/#plycuttersheetbuildsheetbuild","text":"Data evolved by heuristics Semantics: chosen = set in stone ok = as far as we know, this could be chosen <= ok always. When chosen == ok, we are done Attributes sheet_chosen -- PMap(sheet_id, Geom2D). Sheet areas chosen to be included. sheet_ok -- PMap(sheet_id, Geom2D). Sheet areas that are not forbidden by e.g. other sheets or by not being included at all. interside_chosen -- PMap(sheet_id, Geom1D). For each interside, the regions where the interside's sheet has been chosen. interside_ok -- PMap(sheet_id, Geom1D). For each interside, the regions where it would still be ok to choose that side. There is a variety of sanity checks that can be made on a sheetbuild. The checks are relatively slow so by default they are made only infrequently (see sheetbuild.check_interval). Call sb.check(force=True) to force a check to happen.","title":"plycutter.sheetbuild.SheetBuild"},{"location":"api/plycutter/sheetbuild/#plycutter.sheetbuild.SheetBuild-methods","text":"","title":"Methods"},{"location":"api/plycutter/sheetbuild/#plycutter.sheetbuild.SheetBuild.check","text":"Assert that various invariants are true.","title":"check()"},{"location":"api/plycutter/sheetbuild/#plycutter.sheetbuild.SheetBuild.unchoose_interside","text":"State that the range v will never be chosen Create an as-free-as-possible SheetBuild for the given SheetPlex.","title":"unchoose_interside()"},{"location":"api/plycutter/sheetbuild/#_1","text":"","title":""},{"location":"api/plycutter/sheetplex/","text":"plycutter.sheetplex plycutter.sheetplex.SheetPlex Constant data extracted from a 3D model. Three classes represent the objects that live in a sheetplex: Sheet -- a single plywood (or other material) sheet Intersection -- the intersection between two sheets InterSide -- one sheet's side of an Intersection The direct members are intersections -- PMap[str, Intersection] Stored in a pyrsistent.PRecord, see the methods therein for how to manipulate this object. Methods interside ( self , id ) Get the interside with the given id intersides ( self , sheet_id = None ) Return an iterator for intersides of a particular sheet or all limit ( self , sheet_ids ) Return a sub-Sheetplex with only the given sheet_ids included plycutter.sheetplex.Sheet A single sheet that is part of the full model. Contains various data extracted from the 3D model to help geometric reasoning about the joints. Methods project_point4 ( self , pt ) Project a homogeneous point or line to this plane, return 2D point or direction vector for a line plycutter.sheetplex.Intersection An intersection between two sheets. An intersection defines the intersection coordinate system which is a 1D coordinate across the intersection. The joint fingers are defined in terms of that coordinate. Methods sheets ( self ) Return a tuple of the particpating sheet ids side_by_sheet ( self , sheet_id ) Get the InterSide for the given sheet_id. Returns: Type Description None if the given sheet_id is not in this intersection. plycutter.sheetplex.InterSide A particular sheet's view of an intersection. Methods make_fingers ( self , where , fract0 = 0 , fract1 = 1 ) Create a geom for fingers on the sheet on this InterSide. The parameters fract0 and fract1 are useful mostly for visualizations of different rules affecting the fingers. Parameters: Name Type Description Default where Geom1D of sections along joint required fract0 From this fraction coordinate across joint 0 fract1 To this fraction coordinate across joint 1 Returns: Type Description 2D geometry of fingers. opposite ( self , sheetplex ) Get the other InterSide in the Intersection we are part of project_to_1d ( self , geom2d ) Project a Geom2D in Sheet coords to a Geom1D in Intersection coords.","title":"plycutter.sheetplex"},{"location":"api/plycutter/sheetplex/#plycuttersheetplex","text":"","title":"plycutter.sheetplex"},{"location":"api/plycutter/sheetplex/#plycuttersheetplexsheetplex","text":"Constant data extracted from a 3D model. Three classes represent the objects that live in a sheetplex: Sheet -- a single plywood (or other material) sheet Intersection -- the intersection between two sheets InterSide -- one sheet's side of an Intersection The direct members are intersections -- PMap[str, Intersection] Stored in a pyrsistent.PRecord, see the methods therein for how to manipulate this object.","title":"plycutter.sheetplex.SheetPlex"},{"location":"api/plycutter/sheetplex/#plycutter.sheetplex.SheetPlex-methods","text":"","title":"Methods"},{"location":"api/plycutter/sheetplex/#plycutter.sheetplex.SheetPlex.interside","text":"Get the interside with the given id","title":"interside()"},{"location":"api/plycutter/sheetplex/#plycutter.sheetplex.SheetPlex.intersides","text":"Return an iterator for intersides of a particular sheet or all","title":"intersides()"},{"location":"api/plycutter/sheetplex/#plycutter.sheetplex.SheetPlex.limit","text":"Return a sub-Sheetplex with only the given sheet_ids included","title":"limit()"},{"location":"api/plycutter/sheetplex/#plycuttersheetplexsheet","text":"A single sheet that is part of the full model. Contains various data extracted from the 3D model to help geometric reasoning about the joints.","title":"plycutter.sheetplex.Sheet"},{"location":"api/plycutter/sheetplex/#plycutter.sheetplex.Sheet-methods","text":"","title":"Methods"},{"location":"api/plycutter/sheetplex/#plycutter.sheetplex.Sheet.project_point4","text":"Project a homogeneous point or line to this plane, return 2D point or direction vector for a line","title":"project_point4()"},{"location":"api/plycutter/sheetplex/#plycuttersheetplexintersection","text":"An intersection between two sheets. An intersection defines the intersection coordinate system which is a 1D coordinate across the intersection. The joint fingers are defined in terms of that coordinate.","title":"plycutter.sheetplex.Intersection"},{"location":"api/plycutter/sheetplex/#plycutter.sheetplex.Intersection-methods","text":"","title":"Methods"},{"location":"api/plycutter/sheetplex/#plycutter.sheetplex.Intersection.sheets","text":"Return a tuple of the particpating sheet ids","title":"sheets()"},{"location":"api/plycutter/sheetplex/#plycutter.sheetplex.Intersection.side_by_sheet","text":"Get the InterSide for the given sheet_id. Returns: Type Description None if the given sheet_id is not in this intersection.","title":"side_by_sheet()"},{"location":"api/plycutter/sheetplex/#plycuttersheetplexinterside","text":"A particular sheet's view of an intersection.","title":"plycutter.sheetplex.InterSide"},{"location":"api/plycutter/sheetplex/#plycutter.sheetplex.InterSide-methods","text":"","title":"Methods"},{"location":"api/plycutter/sheetplex/#plycutter.sheetplex.InterSide.make_fingers","text":"Create a geom for fingers on the sheet on this InterSide. The parameters fract0 and fract1 are useful mostly for visualizations of different rules affecting the fingers. Parameters: Name Type Description Default where Geom1D of sections along joint required fract0 From this fraction coordinate across joint 0 fract1 To this fraction coordinate across joint 1 Returns: Type Description 2D geometry of fingers.","title":"make_fingers()"},{"location":"api/plycutter/sheetplex/#plycutter.sheetplex.InterSide.opposite","text":"Get the other InterSide in the Intersection we are part of","title":"opposite()"},{"location":"api/plycutter/sheetplex/#plycutter.sheetplex.InterSide.project_to_1d","text":"Project a Geom2D in Sheet coords to a Geom1D in Intersection coords.","title":"project_to_1d()"},{"location":"api/plycutter/geometry/geom1d/","text":"plycutter.geometry.geom1d plycutter.geometry.geom1d.Geom1D Immutable sum of closed-open intervals of an 1D line. Supports the set operations & , | , ^ , - as well as ~ .. Basically, open intervals except that a union of (0, 1) and (1, 2) is (0, 2). One way to accomplish this theoretically is by not including the constructible numbers in the domain. So none of the exact numbers 0, 1 or 2 can ever be part of the infinite set of numbers contained there, only numbers that are greater or less, so then the middle point gets removed nicely. A simpler, equivalent definition is to use lower-bound closed, upper-bound open intervals a la Python ranges but the above is more symmetric in definition wrt the real numbers. :) Note that - is defined as set difference. The intervals can contain infinities. g = Geom1D([[0, 1], [2, 3]]) g.locate(-1) --> -1 g.locate(0) --> 0 g.locate(0.5) --> 1 g.locate(1.5) --> 0 h = Geom1D([[1, 3]]) i = g & h # Equivalent to Geom1D([[2, 3]]) j = g | h # Equivalent to Geom1D([[0, 3]]) k = g - h # Equivalent to Geom1D([[0, 1]]) l = g ^ h # Equivalent to Geom1D([[0, 2]]) m = ~h # Equivalent to Geom1D([[-inf, 1], [3, inf]]) Methods buffer ( self , amount ) Minkowski sum with the interval [-amount, amount]. Amount can be negative to reduce the area. disjoint_pieces ( self ) Return separate Geom1D pieces for disjoint intervals in self. empty () classmethod Return an empty Geom1D. filter ( self , f ) Filter all disjoint intervals in this Geom1D through the function and return a new Geom1D with those intervals that pass the filter. full () classmethod Return a Geom1D that covers the full real line. is_bounded ( self ) Return true if the region described by this Geom1D is bounded. is_empty ( self ) Return true if this Geom1D is empty, i.e. 0-measure. locate ( self , point ) 1 = in -1 = out 0 = indeterminate, possibly on edge, possibly on internal, virtual edge measure1d ( self ) Return the 1d measure (in length) of this object","title":"plycutter.geometry.geom1d"},{"location":"api/plycutter/geometry/geom1d/#plycuttergeometrygeom1d","text":"","title":"plycutter.geometry.geom1d"},{"location":"api/plycutter/geometry/geom1d/#plycuttergeometrygeom1dgeom1d","text":"Immutable sum of closed-open intervals of an 1D line. Supports the set operations & , | , ^ , - as well as ~ .. Basically, open intervals except that a union of (0, 1) and (1, 2) is (0, 2). One way to accomplish this theoretically is by not including the constructible numbers in the domain. So none of the exact numbers 0, 1 or 2 can ever be part of the infinite set of numbers contained there, only numbers that are greater or less, so then the middle point gets removed nicely. A simpler, equivalent definition is to use lower-bound closed, upper-bound open intervals a la Python ranges but the above is more symmetric in definition wrt the real numbers. :) Note that - is defined as set difference. The intervals can contain infinities. g = Geom1D([[0, 1], [2, 3]]) g.locate(-1) --> -1 g.locate(0) --> 0 g.locate(0.5) --> 1 g.locate(1.5) --> 0 h = Geom1D([[1, 3]]) i = g & h # Equivalent to Geom1D([[2, 3]]) j = g | h # Equivalent to Geom1D([[0, 3]]) k = g - h # Equivalent to Geom1D([[0, 1]]) l = g ^ h # Equivalent to Geom1D([[0, 2]]) m = ~h # Equivalent to Geom1D([[-inf, 1], [3, inf]])","title":"plycutter.geometry.geom1d.Geom1D"},{"location":"api/plycutter/geometry/geom1d/#plycutter.geometry.geom1d.Geom1D-methods","text":"","title":"Methods"},{"location":"api/plycutter/geometry/geom1d/#plycutter.geometry.geom1d.Geom1D.buffer","text":"Minkowski sum with the interval [-amount, amount]. Amount can be negative to reduce the area.","title":"buffer()"},{"location":"api/plycutter/geometry/geom1d/#plycutter.geometry.geom1d.Geom1D.disjoint_pieces","text":"Return separate Geom1D pieces for disjoint intervals in self.","title":"disjoint_pieces()"},{"location":"api/plycutter/geometry/geom1d/#plycutter.geometry.geom1d.Geom1D.empty","text":"Return an empty Geom1D.","title":"empty()"},{"location":"api/plycutter/geometry/geom1d/#plycutter.geometry.geom1d.Geom1D.filter","text":"Filter all disjoint intervals in this Geom1D through the function and return a new Geom1D with those intervals that pass the filter.","title":"filter()"},{"location":"api/plycutter/geometry/geom1d/#plycutter.geometry.geom1d.Geom1D.full","text":"Return a Geom1D that covers the full real line.","title":"full()"},{"location":"api/plycutter/geometry/geom1d/#plycutter.geometry.geom1d.Geom1D.is_bounded","text":"Return true if the region described by this Geom1D is bounded.","title":"is_bounded()"},{"location":"api/plycutter/geometry/geom1d/#plycutter.geometry.geom1d.Geom1D.is_empty","text":"Return true if this Geom1D is empty, i.e. 0-measure.","title":"is_empty()"},{"location":"api/plycutter/geometry/geom1d/#plycutter.geometry.geom1d.Geom1D.locate","text":"1 = in -1 = out 0 = indeterminate, possibly on edge, possibly on internal, virtual edge","title":"locate()"},{"location":"api/plycutter/geometry/geom1d/#plycutter.geometry.geom1d.Geom1D.measure1d","text":"Return the 1d measure (in length) of this object","title":"measure1d()"},{"location":"api/plycutter/geometry/geom2d/","text":"plycutter.geometry.geom2d plycutter.geometry.geom2d.Geom2D A set of semi-open convex polygons. (called regularized polygons in CGAL) Supports the set operations & , | , ^ , - as well as ~ .. Like Geom1D, we get a convenient set of properties by asserting that the enclosing lines and the contents are in different spaces ( e.g. rationals and rationals + sqrt(2)) so that unions and differences work in the most natural way possible. Methods all_segments ( self ) Iterate over all line segments defining this geom. Depending on representation, may include internal segments that are not actual external boundary. exterior ( self ) Get the outer boundary as a list of vertices, provided this is a single polygon. holes ( self ) Iterator over the vertex lists of holes, provided this is a single polygon. locate ( self , pt ) Locate point wrt polyset 1 = in -1 = out 0 = indeterminate, possibly on edge, possibly on internal, virtual edge polygons ( self ) Iterate over all distinct polygons (with holes) in this geom. repro ( self ) This gets so long that it is not the default show2d ( self , ax , color , alpha = 1.0 , label = None , linewidth = 0 ) inherited Plot this Geom2D onto the given matplotlib Axes object. to_mpatch ( self , color = 'red' , alpha = 1.0 , label = None , linewidth = 0 , ax = None ) inherited Convert to matplotlib.patches.PathPatch","title":"plycutter.geometry.geom2d"},{"location":"api/plycutter/geometry/geom2d/#plycuttergeometrygeom2d","text":"","title":"plycutter.geometry.geom2d"},{"location":"api/plycutter/geometry/geom2d/#plycuttergeometrygeom2dgeom2d","text":"A set of semi-open convex polygons. (called regularized polygons in CGAL) Supports the set operations & , | , ^ , - as well as ~ .. Like Geom1D, we get a convenient set of properties by asserting that the enclosing lines and the contents are in different spaces ( e.g. rationals and rationals + sqrt(2)) so that unions and differences work in the most natural way possible.","title":"plycutter.geometry.geom2d.Geom2D"},{"location":"api/plycutter/geometry/geom2d/#plycutter.geometry.impl2d.geom2d_simple_holes.Geom2D-methods","text":"","title":"Methods"},{"location":"api/plycutter/geometry/geom2d/#plycutter.geometry.impl2d.geom2d_simple_holes.Geom2D.all_segments","text":"Iterate over all line segments defining this geom. Depending on representation, may include internal segments that are not actual external boundary.","title":"all_segments()"},{"location":"api/plycutter/geometry/geom2d/#plycutter.geometry.impl2d.geom2d_simple_holes.Geom2D.exterior","text":"Get the outer boundary as a list of vertices, provided this is a single polygon.","title":"exterior()"},{"location":"api/plycutter/geometry/geom2d/#plycutter.geometry.impl2d.geom2d_simple_holes.Geom2D.holes","text":"Iterator over the vertex lists of holes, provided this is a single polygon.","title":"holes()"},{"location":"api/plycutter/geometry/geom2d/#plycutter.geometry.impl2d.geom2d_simple_holes.Geom2D.locate","text":"Locate point wrt polyset 1 = in -1 = out 0 = indeterminate, possibly on edge, possibly on internal, virtual edge","title":"locate()"},{"location":"api/plycutter/geometry/geom2d/#plycutter.geometry.impl2d.geom2d_simple_holes.Geom2D.polygons","text":"Iterate over all distinct polygons (with holes) in this geom.","title":"polygons()"},{"location":"api/plycutter/geometry/geom2d/#plycutter.geometry.impl2d.geom2d_simple_holes.Geom2D.repro","text":"This gets so long that it is not the default","title":"repro()"},{"location":"api/plycutter/geometry/geom2d/#plycutter.geometry.impl2d.geom2d_simple_holes.Geom2D.show2d","text":"Plot this Geom2D onto the given matplotlib Axes object.","title":"show2d()"},{"location":"api/plycutter/geometry/geom2d/#plycutter.geometry.impl2d.geom2d_simple_holes.Geom2D.to_mpatch","text":"Convert to matplotlib.patches.PathPatch","title":"to_mpatch()"},{"location":"gallery/format/","text":"Gallery format A single directory for each \"project\". A index.md file in the directory explaining what it is. (Link this into the main mkdocs.yml file in the gallery section). A header, explaining what it is and what it is made of. Use an <img> tag with align=\"right\" to show Some pictures. Use <img> tags. An .stl file is optional. Other source files (e.g. OpenSCAD, Fusion 360, ...) are optional. TODO: STL visualizaton; figure out an automatic build of all projects with latest plycutter plus visualization of the resulting sheet model.","title":"Gallery format"},{"location":"gallery/format/#gallery-format","text":"A single directory for each \"project\". A index.md file in the directory explaining what it is. (Link this into the main mkdocs.yml file in the gallery section). A header, explaining what it is and what it is made of. Use an <img> tag with align=\"right\" to show Some pictures. Use <img> tags. An .stl file is optional. Other source files (e.g. OpenSCAD, Fusion 360, ...) are optional. TODO: STL visualizaton; figure out an automatic build of all projects with latest plycutter plus visualization of the resulting sheet model.","title":"Gallery format"},{"location":"gallery/dollhouse/","text":"Dollhouse Author: Tuomas Lukka (tjltjl) Material: 6mm plywood Tools: Fusion 360 The project that launched plycutter. The original CAD model: Laser-cut and glued: Painted and with wallpaper:","title":"Dollhouse"},{"location":"gallery/dollhouse/#dollhouse","text":"Author: Tuomas Lukka (tjltjl) Material: 6mm plywood Tools: Fusion 360 The project that launched plycutter. The original CAD model: Laser-cut and glued: Painted and with wallpaper:","title":"Dollhouse"},{"location":"gallery/virtalahde-kotelo/","text":"Box for DPS5020 Digital Power Supply Author: Jukka J\u00e4rvenp\u00e4\u00e4/Helsinki Hacklab Material: 3mm acrylic Tools: Fusion 360 The original CAD model:","title":"Box for DPS5020 Digital Power Supply"},{"location":"gallery/virtalahde-kotelo/#box-for-dps5020-digital-power-supply","text":"Author: Jukka J\u00e4rvenp\u00e4\u00e4/Helsinki Hacklab Material: 3mm acrylic Tools: Fusion 360 The original CAD model:","title":"Box for DPS5020 Digital Power Supply"}]}